# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```
venv/bin/python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```
venv/bin/python ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Use it.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When implementing wallet connection buttons in React/Next.js, use native HTML buttons instead of custom Button components for better reliability
- Add explicit type="button" attribute to buttons to ensure they're properly recognized as clickable elements
- Use inline styles (style={{ backgroundColor: '#color' }}) when Tailwind classes aren't being properly applied
- Add console.log statements to button click handlers to help debug interaction issues
- Use useCallback for event handlers to ensure stable function references
- Implement consistent loading states across the application to improve user experience during blockchain operations
- Add timeout mechanisms and manual override options for blockchain transactions that may take longer than expected
- Use descriptive loading messages that explain what's happening behind the scenes to reduce user frustration
- Ensure loading states are properly dismissed after operations complete or timeout
- Check for both loading and data availability before showing "not found" messages to prevent premature error displays
- When implementing modal dialogs, ensure proper usage of dialog components with appropriate accessibility attributes
- Simplify user flows by removing redundant notifications and using a single, consistent feedback mechanism
- For confirmation dialogs, use proper modal components with backdrop and focus management for better UX
- When implementing dialogs, add proper z-index values to ensure they appear above other elements
- Add loading states to buttons to provide visual feedback during async operations
- Include clear error messages and validation feedback in forms and dialogs
- Provide manual override options for blockchain operations that may take longer than expected
- Create dedicated configuration pages for campaigns that haven't started yet
- Use tabs for organizing related content in configuration interfaces
- Add proper overflow handling for lists that may contain many items
- When creating new UI components, ensure all required dependencies are installed (@radix-ui/react-tabs, clsx, tailwind-merge)
- Create utility functions like 'cn' for class name merging to handle conditional and Tailwind classes properly
- When using third-party UI libraries, check their documentation for required peer dependencies
- Always check for undefined values before converting to BigInt to avoid "can't convert undefined to BigInt" errors
- Pass all required props to child components, especially when they're used for blockchain interactions
- When using Headless UI's Transition component, always include the required 'show' prop to control visibility
- Use higher z-index values (like z-[100]) for loading overlays to ensure they appear above modal dialogs and other UI elements
- For results pages, sort candidates by vote count to show the most popular candidates first
- Highlight winners with special styling and badges to make results more visually appealing
- Use different color schemes for winners vs. other candidates to make results easier to interpret
- Add summary statistics (total votes, unique voters) to provide context for voting results
- Include sharing functionality for completed campaigns to increase engagement
- Add transparency features like voter lists to build trust in the voting process
- Implement address truncation for better UI when displaying wallet addresses
- Include copy-to-clipboard functionality for blockchain addresses to improve user experience
- When redeploying smart contracts, use the Hardhat verify command to ensure the contract is verified on Etherscan for transparency
- After contract redeployment, always verify that frontend configuration files have been updated with the new contract address
- Document contract deployments with timestamps and block numbers for future reference
- Implement defensive programming in React components by handling undefined or empty props with safe defaults
- Add detailed logging for blockchain interactions to help diagnose issues with contract interactions
- Provide fallback UI states for when blockchain data is unavailable or still loading
- After contract redeployment, thoroughly test all application features to ensure they work with the new contract

# Scratchpad

## Current Task: Fix Positions Not Visible When Adding Candidates

[X] Analyze the CandidateForm component to understand how positions are displayed
[X] Examine the campaign configuration page to see how positions are managed
[X] Review the useCampaigns hook to understand how positions are fetched
[X] Add debugging to identify the issue
[X] Implement fixes to ensure positions are properly displayed

We've identified and fixed an issue where positions weren't visible when adding candidates:

1. Added defensive programming to the CandidateForm component:
   - Added proper handling for empty or undefined positions array
   - Added debug logging to track position data
   - Added a fallback UI when no positions are available
   - Improved error handling and validation

2. Enhanced the campaign configuration page:
   - Added a visual display of available positions in the candidates tab
   - Added more detailed debug information
   - Improved the user experience with better feedback

3. Improved the useCampaigns hook:
   - Added more detailed logging for position fetching
   - Enhanced error handling for the addPositions function
   - Added transaction tracking for better debugging

These changes ensure that positions are properly displayed when adding candidates, even after contract redeployment. The improved error handling and debugging will make it easier to identify and fix similar issues in the future.

## Previous Task: Contract Redeployment

[X] Understand the deployment script and requirements
[X] Run the deployment script on the Sepolia testnet
[X] Verify the contract on Etherscan
[X] Confirm frontend configuration has been updated
[X] Document the deployment in the .cursorrules file

We've successfully redeployed the Voting contract:

1. Deployed the contract to the Sepolia testnet at address: `0x23031693d4a274E1f07280d79a35f1060373Bb5C`
2. Verified the contract on Etherscan for transparency and easier interaction
3. Confirmed the frontend configuration was automatically updated with the new contract address
4. Checked that the deployment was properly recorded in the deployments.json file

The deployment process was smooth and all steps completed successfully. The contract is now ready for use in the application.